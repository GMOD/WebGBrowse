#============================================================================
#
# WebGB::Config2TrackData.pm
#
# The Config2TrackData convertor reverse engineers the track configuration 
# content for the WebGBrowse utility from a pre-existing configuration file.
# This translator reads only the data WebGBrowse expects and ignores any
# extraneous information. In other words, this convertor assumes that this 
# pre-existing configuration file is generated from WebGBrowse itself.
#
# Written by Ram Podicheti <mnrusimh@indiana.edu>
#
# $ID: Config2TrackData.pm,v 0.01 2009/02/20 00:22:28 cgb Exp $
#
#============================================================================

package WebGB::Config2TrackData;

use strict;
use warnings;
use WebGB::Exceptions;
use WebGB::TrackData;
use WebGB::GeneralData;
use YAML;
use 5.008;
use Clone qw(clone);
use Data::Dumper;

our $VERSION = '0.01';
our @ISA = ();

#------------------------------------------------------------------------
# new($generalSettingsFile, $featureSetFile, $glyphLibraryFile, 
# 	$trackConfigurationFile, $configFile)
#
# Module constructor. It accepts five arguments.
# 1. $generalSettingsFile: The file meant to store the configuration 
# 	information of the general section. The field of our interest is
# 	the description. The rest of the general section is not available 
# 	for editing in this version of WebGBrowse.
# 2. $featureSetFile: a file generated by WebGB::GFFData containing the 
# 	list of all unique features from the uploaded GFF3 file.
# 3. $glyphLibraryFile: The base schema library for the available 
# 	glyphs.
# 4. $trackConfigurationFile: The file that stores the individual 
# 	track settings.
# 5. $configFile: The uploaded GBrowse configuration file serving as a 
# template
#
# It opens the template configuration file and loads the individual track 
# information. It ignores all those tracks which do not conform to the 
# WebGBrowse configuration standards. It compares the configured features
# to the available feature list from the uploaded GFF file and eliminates 
# all the tracks with non-existing features. It also updates the 
# description in the general settings configuration file.
#
# Returns a reference to a newly created WebGB::Config2TrackData object.
#------------------------------------------------------------------------

sub new {
	my ($class, $generalSettingsFile, $featureSetFile, $glyphLibraryFile, $trackConfigurationFile, $configFile) = @_;
	open CONFIG, '<', $configFile or 
		WebGB::Exceptions::WebGBException::ConfigException::InvalidParameterException->throw(
			'error' => "Could not locate $configFile for input: $!",
			'ParamValue' => $configFile
		);
	my %configData = ();
	my $trackNumber = 1000;
	my $readGlyphData = 0;
	my %configTrackGlyphData = ();
	my $desc = '';
	my @tracksAvailable = ();
	my $configLineNo = 0;
	while (<CONFIG>) {
		$configLineNo++;
		if ($_) {
			$_ = _trim($_);
			unless ($_ eq '') {
				unless ($readGlyphData) {
					if (/^description = (.*)$/) {
						$desc = $1;
					}
				}

				if (/^\[.+\]$/) {
					if ($readGlyphData) {
						$readGlyphData = 0;
						if (%configTrackGlyphData) {
							my %cloneConfigTrackGlyphData = %{clone(\%configTrackGlyphData)};
							$configData{$trackNumber} = \%cloneConfigTrackGlyphData;
							push @tracksAvailable, $trackNumber;
							%configTrackGlyphData = ();
						}
					}
					if (/^\[Track(\d\d\d\d)\]$/) {
						$readGlyphData = 1;
						$trackNumber = $1;
					}
				} else {
					if ($readGlyphData) {
						my @configTrackGlyphDataParts = split/=/;
						WebGB::Exceptions::WebGBException::ConfigException::InvalidTrackLineException->throw(
							'error' => "Not a well formed line (No: $configLineNo) in the configuration file : <br><i>$_</i>"
						) unless ((scalar @configTrackGlyphDataParts) >= 2);
						if ((scalar @configTrackGlyphDataParts) == 2) {
							$configTrackGlyphData{_trim($configTrackGlyphDataParts[0])} = _trim($configTrackGlyphDataParts[1]);
						} else {
							my $configTrackGlyphDataKey = shift @configTrackGlyphDataParts;
							$configTrackGlyphData{_trim($configTrackGlyphDataKey)} = _trim(join('=', @configTrackGlyphDataParts));
						}
					}
				}
			}
		}
	}
	if ($readGlyphData) { 
		$readGlyphData = 0; 
		if (%configTrackGlyphData) { 
			my %cloneConfigTrackGlyphData = %{clone(\%configTrackGlyphData)}; 
			$configData{$trackNumber} = \%cloneConfigTrackGlyphData; 
			push @tracksAvailable, $trackNumber; 
			%configTrackGlyphData = (); 
		} 
	}

	my $trackData = WebGB::TrackData->new($featureSetFile, $glyphLibraryFile, $trackConfigurationFile);
	my @features = $trackData->getFeatureList;
	my @glyphs = $trackData->getGlyphList;
	foreach (@tracksAvailable) {
		my $curTrackAvailable = $_;
		my $feature = ${$configData{$curTrackAvailable}}{'feature'};
		if ($feature) {
			if ((scalar grep(/^$feature$/, @features)) > 0) {
				my $glyph = ${$configData{$curTrackAvailable}}{'glyph'};
				if ($glyph) {
					if ((scalar grep(/^$glyph$/, @glyphs)) > 0) {
						$trackData->addTrack($feature, $glyph);
						my %trackConfigurationData = $trackData->getTrackConfiguration;
						my @confGlyph = @{$trackConfigurationData{'Tracks'}{$trackConfigurationData{'ActiveTrack'}}{'glyph'}};
						foreach (@confGlyph) {
							foreach (@{$_->{'sub'}}) {
								if (${$configData{$curTrackAvailable}}{$_->{'CONF_TAG'}}) {
									if ($_->{'templ'} && ($_->{'templ'} eq 'check')) {
										if (${$configData{$curTrackAvailable}}{$_->{'CONF_TAG'}} eq '1') {
											$_->{'VALUE'} = $_->{'NAME'} . '1';
										} else {
											$_->{'VALUE'} = 0;
										}
									} else {
										$_->{'VALUE'} = ${$configData{$curTrackAvailable}}{$_->{'CONF_TAG'}};
									}
								}
							}
						}
						$trackData->resetEditMode;
					}
				}
			}
		}
	}
	$trackData->saveTrackConfigurationToFile($trackConfigurationFile);

	my $generalData = WebGB::GeneralData->new($generalSettingsFile);
	$generalData->setDescription($desc);
	$generalData->saveGeneralSettingsToFile($generalSettingsFile);

	my $self = {
		'SUCCESS' => 1
	};
	bless $self, $class;
	return $self;
}



#------------------------------------------------------------------------
# _trim 
#
# Internal subroutine to remove whitespace from the start and end of the string
#------------------------------------------------------------------------
sub _trim($) { 
	my $string = shift; 
	$string =~ s/^\s+//; 
	$string =~ s/\s+$//; 
	return $string; 
}


1;
